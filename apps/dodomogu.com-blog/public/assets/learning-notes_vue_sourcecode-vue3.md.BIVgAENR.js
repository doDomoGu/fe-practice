import{_ as e,c as a,o as i,a2 as t}from"./chunks/framework.DOwwFb84.js";const g=JSON.parse('{"title":"Vue 源码（下）","description":"","frontmatter":{},"headers":[],"relativePath":"learning-notes/vue/sourcecode-vue3.md","filePath":"learning-notes/vue/sourcecode-vue3.md"}'),l={name:"learning-notes/vue/sourcecode-vue3.md"},s=t(`<h1 id="vue-源码-下" tabindex="-1">Vue 源码（下） <a class="header-anchor" href="#vue-源码-下" aria-label="Permalink to &quot;Vue 源码（下）&quot;">​</a></h1><blockquote><p>为什么要开发Vue3</p></blockquote><h2 id="vue2-x-存在的问题" tabindex="-1">Vue2.x 存在的问题 <a class="header-anchor" href="#vue2-x-存在的问题" aria-label="Permalink to &quot;Vue2.x 存在的问题&quot;">​</a></h2><ul><li><p>代码结构</p><ul><li>Vue2源码项目架构比较传统，能力集中，要使用必须整理引入整个框架，无法单独使用某一个功能或者能力，如defineReactive、Observer等。</li><li>Vue2分编译版本和运行时版本，运行时版本没有编译能力的，需要额外引用vue-template-complier，类库分散，不易于整体进行优化，如tree-shaking。</li></ul></li><li><p>性能优化的空间</p><ul><li>dom-diff: template -&gt; render</li><li>Object.defineProperty: 对应对象属性的劫持，浅层属性可以劫持到，深层嵌套的属性也可以用$set设置，但是Array数组类型是封装了一层处理方法，势必影响到了一定的执行性能</li><li>stateMixin: props/data 都会生成数据劫持，做成响应式的，但不是所有的数据都需要响应式的，影响了性能。</li></ul></li><li><p>选项式的页面配置模式</p><ul><li>不利于多人进行协同开发</li><li>可维护性较差</li></ul></li><li><p>浏览器真的需要老版本吗</p></li></ul><h2 id="vue3诞生中存在的问题" tabindex="-1">Vue3诞生中存在的问题 <a class="header-anchor" href="#vue3诞生中存在的问题" aria-label="Permalink to &quot;Vue3诞生中存在的问题&quot;">​</a></h2><ul><li>太多的破坏性修改 breaking changes <ul><li>默认使用 <code>&lt;script setup&gt;</code> 组合式API</li></ul></li><li>生态影响 <ul><li>弃用mixin</li></ul></li><li>发布节奏 <ul><li>过早的发布，接受不了，不够完善</li></ul></li></ul><h2 id="vue3的优化" tabindex="-1">Vue3的优化 <a class="header-anchor" href="#vue3的优化" aria-label="Permalink to &quot;Vue3的优化&quot;">​</a></h2><p>相较于Vue2做了哪些优化</p><h3 id="结构上的优化-monorepo" tabindex="-1">结构上的优化 - monorepo <a class="header-anchor" href="#结构上的优化-monorepo" aria-label="Permalink to &quot;结构上的优化 - monorepo&quot;">​</a></h3><p>原子结构 可独立拆分引用 拓补结构 =&gt; 可做业务上的拆分</p><h3 id="性能上的优化" tabindex="-1">性能上的优化 <a class="header-anchor" href="#性能上的优化" aria-label="Permalink to &quot;性能上的优化&quot;">​</a></h3><h4 id="移除了很多使用率比较低的api" tabindex="-1">移除了很多使用率比较低的api <a class="header-anchor" href="#移除了很多使用率比较低的api" aria-label="Permalink to &quot;移除了很多使用率比较低的api&quot;">​</a></h4><p>如filter</p><h4 id="tree-shaking-产物打包优化" tabindex="-1">tree-shaking =&gt; 产物打包优化 <a class="header-anchor" href="#tree-shaking-产物打包优化" aria-label="Permalink to &quot;tree-shaking =&gt; 产物打包优化&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> components </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;components&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// components.input</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { imput } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;components&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref, computed, watch } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span></code></pre></div><h4 id="编译优化" tabindex="-1">编译优化 <a class="header-anchor" href="#编译优化" aria-label="Permalink to &quot;编译优化&quot;">​</a></h4><p>compile阶段对静态模版进行分析 =&gt; 分析树 &lt;= PatchFlag 用于区分各个类型的节点</p><h4 id="数据劫持优化" tabindex="-1">数据劫持优化 <a class="header-anchor" href="#数据劫持优化" aria-label="Permalink to &quot;数据劫持优化&quot;">​</a></h4><ul><li>Vue2: Object.defineProperty <ul><li>无法检测对象属性的增加或删除 =&gt; 通过$set $delete 操作</li><li>数组 =&gt; 通过封装push、pop等操作</li><li>层级较深的对象 =&gt; 递归遍历</li></ul></li><li>Vue3: Proxy =&gt; 底层优化</li></ul><h2 id="源码解读" tabindex="-1">源码解读 <a class="header-anchor" href="#源码解读" aria-label="Permalink to &quot;源码解读&quot;">​</a></h2><h3 id="模版编译" tabindex="-1">模版编译 <a class="header-anchor" href="#模版编译" aria-label="Permalink to &quot;模版编译&quot;">​</a></h3><ol><li>词法分析阶段（baseParse）: template =&gt; AST</li><li>指令和语法的转化阶段（transform）: AST =&gt; 解析不同的节点进行区分 PatchFlag =&gt; 不同类型的转换</li><li>可执行函数的生成阶段（generator）： 转化后的AST生成渲染函数</li></ol><blockquote><p>主编译入口: core/packages/compiler-core/src/index.ts</p></blockquote><h3 id="基于proxy的响应式" tabindex="-1">基于Proxy的响应式 <a class="header-anchor" href="#基于proxy的响应式" aria-label="Permalink to &quot;基于Proxy的响应式&quot;">​</a></h3><ol><li>数据劫持 | 数据响应（reactive）: 监测数据变化 =&gt; 函数监听化执行</li><li>依赖收集 (effect副作用函数)<br> 当前VM实例上挂载effect =&gt; 当前生效的(activeEffect)切换为这个effect<br> =&gt; 在这个effect上创建deps等属性, 用于传递依赖</li><li>订阅 | 变量访问 =&gt; 触发对应的get() =&gt; 创建deps对象 (targetMap)<br> =&gt; targetMap中的deps可以做为属性进行添加 =&gt; depsMap <ul><li>depsMap会被添加activeEffect - 被收集的订阅方</li><li>activeEffect 中也同时存在deps数组，用于存放关联方的depsMap - 订阅者</li></ul></li><li>派发更新 (ref) 依赖的set()被触发 =&gt; Reflect.set()修改对应的属性 =&gt; 获取到targetMap订阅方(depsMap)<br> =&gt; 链条传递 =&gt; 触发渲染</li></ol><blockquote><p>主响应式入口 /core/packages/reactivity/src/index.ts</p></blockquote>`,26),r=[s];function o(n,p,h,c,u,d){return i(),a("div",null,r)}const m=e(l,[["render",o]]);export{g as __pageData,m as default};
